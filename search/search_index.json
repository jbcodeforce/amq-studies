{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AMQ Studies Apache Active MQ started in 2004 as the first open source JMS specification implementation but has evolved to a event driven architecture backbone, with peristence, massive scalability and high availability. It is a big product with a lot of features. It is now in two flavors: classic and artemis. Artemis is the new architecture. Characteristics Heterogeneous application integration Java, C/C++, .NET, Perl, PHP, Python, Ruby JMS compliant from design pub / sub and point-to-point communication style. With Topic, subscription may be durable which means they retain a copy of each message sent to the topic until the subscriber consumes them Guarantee the mesage will be delivered once and only once to each consumer of a queue or a durable topic. Support the sending and acknowledgement of multiple messages in a single local transaction Support XA transaction in Java using JTA Message can be persisted in permanent storage, and will survice server crashes and restart. Support HTTP/S via REST call, STOMP, MQTT, AMQT Provide clustering model where messages can be intelligently load balanced between the servers in the cluster, according to the number of consumers on each node, and whether they are ready for messages Architecture Here is a diagram of Artemis architecture: Each broker server is a Java POJO. Use persistent journal to persist messages on disk. It is possible to plug a JDBC and remote database. (This experimental) Client applications can interact with any protocol which are mapped to Core protocol. JMS API has a provider that uses the core client library. Broker always just deals with core API interactions. The normal stand-alone messaging broker configuration comprises a core messaging broker and a number of protocol managers that provide support for the various protoco Clustering The goal is to group servers so they can share the message processing. Each server within the cluster manages its own messages and handles its own connections. Cluster is formed by each node declaring cluster connections to other nodes in the broker.xml configuration file. Cluster connections allow messages to flow between the nodes of the cluster to balance load. There are a set of interesting features to consider: Server discovery: each broker shares their connection configuration with client or other server so they can discover them, without explicit knowledge of their static end point. To establish the first connection, clients or servers use dynamic discovery using UDP multicast, or the JGroups. To support discovery, each server define a broadcast group , which is the means by which a server broadcasts connectors information over the network. Connector defines how the client or server can connect to this broker. When to use it For point to point communication between Java microservices To replace RPC style synchronous calls Systems that rely upon synchronous requests typically have a limited ability to scale because eventually requests will begin to back up, thereby slowing the whole system. To adopt more loosely coupling between applications Loosely coupled architectures, on the other hand, exhibit fewer dependencies, making them better at handling unforeseen changes. Not only will a change to one component in the system not ripple across the entire system, but component interaction is also dramatically simplified. To implement stateful operation for complex event processing High Availability JMS Summary The goal of JMS is to provide a vendor neutral API for messaging in Java. It is an abstraction layer between Java class and Message Oriented Middleware. JMS client: Java application to send and receive messages. JMS producer: A client application that creates and sends JMS messages. JMS consumer: A client application that receives and processes JMS messages. JMS provider: The implementation of the JMS interfaces to integrate with a specific MOM. JMS message: carry data and meta data between clients JMS domains: styles of messaging: point-to-point and publish/subscribe. Administered objects: Preconfigured JMS objects, accessible via JNDI, contain provider configuration to be used by clients. Connection factory: Clients use a connection factory to create connections to the JMS provider. Destination: An object to which messages are addressed and sent and from which messages are received. See producer and consumer code under the examples/basicjms folder and the explanation note .","title":"Introduction"},{"location":"#amq-studies","text":"Apache Active MQ started in 2004 as the first open source JMS specification implementation but has evolved to a event driven architecture backbone, with peristence, massive scalability and high availability. It is a big product with a lot of features. It is now in two flavors: classic and artemis. Artemis is the new architecture.","title":"AMQ Studies"},{"location":"#characteristics","text":"Heterogeneous application integration Java, C/C++, .NET, Perl, PHP, Python, Ruby JMS compliant from design pub / sub and point-to-point communication style. With Topic, subscription may be durable which means they retain a copy of each message sent to the topic until the subscriber consumes them Guarantee the mesage will be delivered once and only once to each consumer of a queue or a durable topic. Support the sending and acknowledgement of multiple messages in a single local transaction Support XA transaction in Java using JTA Message can be persisted in permanent storage, and will survice server crashes and restart. Support HTTP/S via REST call, STOMP, MQTT, AMQT Provide clustering model where messages can be intelligently load balanced between the servers in the cluster, according to the number of consumers on each node, and whether they are ready for messages","title":"Characteristics"},{"location":"#architecture","text":"Here is a diagram of Artemis architecture: Each broker server is a Java POJO. Use persistent journal to persist messages on disk. It is possible to plug a JDBC and remote database. (This experimental) Client applications can interact with any protocol which are mapped to Core protocol. JMS API has a provider that uses the core client library. Broker always just deals with core API interactions. The normal stand-alone messaging broker configuration comprises a core messaging broker and a number of protocol managers that provide support for the various protoco","title":"Architecture"},{"location":"#clustering","text":"The goal is to group servers so they can share the message processing. Each server within the cluster manages its own messages and handles its own connections. Cluster is formed by each node declaring cluster connections to other nodes in the broker.xml configuration file. Cluster connections allow messages to flow between the nodes of the cluster to balance load. There are a set of interesting features to consider: Server discovery: each broker shares their connection configuration with client or other server so they can discover them, without explicit knowledge of their static end point. To establish the first connection, clients or servers use dynamic discovery using UDP multicast, or the JGroups. To support discovery, each server define a broadcast group , which is the means by which a server broadcasts connectors information over the network. Connector defines how the client or server can connect to this broker.","title":"Clustering"},{"location":"#when-to-use-it","text":"For point to point communication between Java microservices To replace RPC style synchronous calls Systems that rely upon synchronous requests typically have a limited ability to scale because eventually requests will begin to back up, thereby slowing the whole system. To adopt more loosely coupling between applications Loosely coupled architectures, on the other hand, exhibit fewer dependencies, making them better at handling unforeseen changes. Not only will a change to one component in the system not ripple across the entire system, but component interaction is also dramatically simplified. To implement stateful operation for complex event processing","title":"When to use it"},{"location":"#high-availability","text":"","title":"High Availability"},{"location":"#jms-summary","text":"The goal of JMS is to provide a vendor neutral API for messaging in Java. It is an abstraction layer between Java class and Message Oriented Middleware. JMS client: Java application to send and receive messages. JMS producer: A client application that creates and sends JMS messages. JMS consumer: A client application that receives and processes JMS messages. JMS provider: The implementation of the JMS interfaces to integrate with a specific MOM. JMS message: carry data and meta data between clients JMS domains: styles of messaging: point-to-point and publish/subscribe. Administered objects: Preconfigured JMS objects, accessible via JNDI, contain provider configuration to be used by clients. Connection factory: Clients use a connection factory to create connections to the JMS provider. Destination: An object to which messages are addressed and sent and from which messages are received. See producer and consumer code under the examples/basicjms folder and the explanation note .","title":"JMS Summary"},{"location":"basicjms/","text":"Basic JMS examples Some example of the JMS consumer and producer API and implementation considerations. Pre-requisites Be sure to have access to Active MQ artemis broker, in docker or on a cluster. Major JMS concepts The basic api can be summarized in the following diagram from codenotfound.com ConnectionFactory is used to create JMS connection to the provider. It needs the broker URL, username and password. Connection is the encapsulation to the TCP/IP socket between the client and the provider. Always close connection to avoid congestion on the Provider side. A session is a single-threaded context for producing and consuming messages. A session provides a transactional context with which to group a set of sends and receives into an atomic unit of work. A MessageProducer is an object that is created by a session and used for sending messages to a destination A MessageConsumer is an object that is created by a session and used for receiving messages Destination is a queue or a topic Message includes metadata. A client can have multiple connections and in a connection can have multiple sessions. Each session can have producer, consumer or both. So a client can go to different destinations: queues and topics. Producing text message In JMS 1.1 producer.send() blocks untile remote peer acknowledges delivery. But JMS 2.0, support asynchronous send with CompletionListener. New classes are added like JMSProducer, and JMSConsumer which are lightweight, and have operations to access message properties and to support chaining. In JMS 2.0, the JMSContext implements the AutoCloseable interface, so no need to call the close() operation, if the creation of the JMSContext is in try with resources and catch. See JMS 2.0 API specifics in this document . Vert.x","title":"JMS Basis"},{"location":"basicjms/#basic-jms-examples","text":"Some example of the JMS consumer and producer API and implementation considerations.","title":"Basic JMS examples"},{"location":"basicjms/#pre-requisites","text":"Be sure to have access to Active MQ artemis broker, in docker or on a cluster.","title":"Pre-requisites"},{"location":"basicjms/#major-jms-concepts","text":"The basic api can be summarized in the following diagram from codenotfound.com ConnectionFactory is used to create JMS connection to the provider. It needs the broker URL, username and password. Connection is the encapsulation to the TCP/IP socket between the client and the provider. Always close connection to avoid congestion on the Provider side. A session is a single-threaded context for producing and consuming messages. A session provides a transactional context with which to group a set of sends and receives into an atomic unit of work. A MessageProducer is an object that is created by a session and used for sending messages to a destination A MessageConsumer is an object that is created by a session and used for receiving messages Destination is a queue or a topic Message includes metadata. A client can have multiple connections and in a connection can have multiple sessions. Each session can have producer, consumer or both. So a client can go to different destinations: queues and topics.","title":"Major JMS concepts"},{"location":"basicjms/#producing-text-message","text":"In JMS 1.1 producer.send() blocks untile remote peer acknowledges delivery. But JMS 2.0, support asynchronous send with CompletionListener. New classes are added like JMSProducer, and JMSConsumer which are lightweight, and have operations to access message properties and to support chaining. In JMS 2.0, the JMSContext implements the AutoCloseable interface, so no need to call the close() operation, if the creation of the JMSContext is in try with resources and catch. See JMS 2.0 API specifics in this document .","title":"Producing text message"},{"location":"basicjms/#vertx","text":"","title":"Vert.x"},{"location":"deployment/","text":"AMQ Deployments Run Active MQ Artemis local using docker Download tar file from https://activemq.apache.org/components/artemis/download/ . Unzip and then set the $ARTEMIS_HOME environment variable to the folder containing artemis. (e.g. < somewhere>/apache-artemis-2.10.0) Clone the official docker files for ubuntu or centos from this github: https://github.com/apache/activemq-artemis . The do the steps described in this repository README. I built the centos image: docker build -f ./docker/Dockerfile-centos -t artemis-centos . Start with the command: docker run -it -p 61616:61616 -p 8161:8161 -v $ARTEMIS_HOME/instance:/var/lib/artemis-instance artemis-centos Or you can run the broker in the background using: \"/var/lib/artemis-instance/bin/artemis-service\" start _ _ _ / \\ ____| |_ ___ __ __(_) _____ / _ \\| _ \\ __|/ _ \\ \\/ | |/ __/ / ___ \\ | \\/ |_/ __/ |\\/| | |\\___ \\ /_/ \\_\\| \\__\\____|_| |_|_|/___ / Apache ActiveMQ Artemis 2.10.0 2019-09-06 16:03:45,113 INFO [org.apache.activemq.artemis.integration.bootstrap] AMQ101000: Starting ActiveMQ Artemis Server Access the ActiveMQ admin-console as usual. Just invoke http://localhost:8161/ artemis/artemis The artemis management console looks like: Running on Openshift Create an application using one of the oc template: openshift/amq-broker-71-basic oc new-app amq-broker-71-basic -p AMQ_PROTOCOL=openwire,amqp,stomp,mqtt -p AMQ_USER=amquser -pAMQ_PASSWORD=amqpassword -p AMQ_QUEUES=example which create brokers with the different protocols. See the AMQP, reactive library rhea project with different JavaScripts examples. [Red Hat Openshift Application Runtime(https://developers.redhat.com/products/rhoar/overview)","title":"Deployments"},{"location":"deployment/#amq-deployments","text":"","title":"AMQ Deployments"},{"location":"deployment/#run-active-mq-artemis-local-using-docker","text":"Download tar file from https://activemq.apache.org/components/artemis/download/ . Unzip and then set the $ARTEMIS_HOME environment variable to the folder containing artemis. (e.g. < somewhere>/apache-artemis-2.10.0) Clone the official docker files for ubuntu or centos from this github: https://github.com/apache/activemq-artemis . The do the steps described in this repository README. I built the centos image: docker build -f ./docker/Dockerfile-centos -t artemis-centos . Start with the command: docker run -it -p 61616:61616 -p 8161:8161 -v $ARTEMIS_HOME/instance:/var/lib/artemis-instance artemis-centos Or you can run the broker in the background using: \"/var/lib/artemis-instance/bin/artemis-service\" start _ _ _ / \\ ____| |_ ___ __ __(_) _____ / _ \\| _ \\ __|/ _ \\ \\/ | |/ __/ / ___ \\ | \\/ |_/ __/ |\\/| | |\\___ \\ /_/ \\_\\| \\__\\____|_| |_|_|/___ / Apache ActiveMQ Artemis 2.10.0 2019-09-06 16:03:45,113 INFO [org.apache.activemq.artemis.integration.bootstrap] AMQ101000: Starting ActiveMQ Artemis Server Access the ActiveMQ admin-console as usual. Just invoke http://localhost:8161/ artemis/artemis The artemis management console looks like:","title":"Run Active MQ Artemis local using docker"},{"location":"deployment/#running-on-openshift","text":"Create an application using one of the oc template: openshift/amq-broker-71-basic oc new-app amq-broker-71-basic -p AMQ_PROTOCOL=openwire,amqp,stomp,mqtt -p AMQ_USER=amquser -pAMQ_PASSWORD=amqpassword -p AMQ_QUEUES=example which create brokers with the different protocols. See the AMQP, reactive library rhea project with different JavaScripts examples. [Red Hat Openshift Application Runtime(https://developers.redhat.com/products/rhoar/overview)","title":"Running on Openshift"}]}