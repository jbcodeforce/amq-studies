{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AMQ Studies Apache Active MQ starts as the first open source JMS specification implementation but ahs evolved to a event driven architecture backbone, with peristence, massive scalability and high availability. It has now in two flavors: classic and artemis. Characteristics Heterogeneous application integration Java, C/C++, .NET, Perl, PHP, Python, Ruby JMS compliant from design pub / sub and point-to-point communication style. With Topic, subscription may be durable which means they retain a copy of each message sent to the topic until the subscriber consumes them Guarantee the mesage will be delivered once and only once to each consumer of a queue or a durable topic. Support the sending and acknowledgement of multiple messages in a single local transaction Support XA transaction in Java using JTA Message can be persisted in permanent storage, and will survice server crashes and restart. Support HTTP/S via REST call, STOMP, MQTT, AMQT Provide clustering model where messages can be intelligently load balanced between the servers in the cluster, according to the number of consumers on each node, and whether they are ready for messages When to use it For point to point communication between Java microservices To replace RPC style synchronous calls Systems that rely upon synchronous requests typically have a limited ability to scale because eventually requests will begin to back up, thereby slowing the whole system. To adopt more loosely coupling between applications Loosely coupled architectures, on the other hand, exhibit fewer dependencies, making them better at handling unforeseen changes. Not only will a change to one component in the system not ripple across the entire system, but component interaction is also dramatically simplified. To implement stateful operation for complex event processing High Availability JMS Summary The goal of JMS is to provide a vendor neutral API for messaging in Java. It is an abstraction layer between Java class and Message Oriented Middleware. JMS client: Java application to send and receive messages. JMS producer: A client application that creates and sends JMS messages. JMS consumer: A client application that receives and processes JMS messages. JMS provider: The implementation of the JMS interfaces to integrate with a specific MOM. JMS message: carry data and meta data between clients JMS domains: styles of messaging: point-to-point and publish/subscribe. Administered objects: Preconfigured JMS objects, accessible via JNDI, contain provider configuration to be used by clients. Connection factory: Clients use a connection factory to create connections to the JMS provider. Destination: An object to which messages are addressed and sent and from which messages are received. See producer and consumer code under the examples/basicjms folder and the explanation note .","title":"Introduction"},{"location":"#amq-studies","text":"Apache Active MQ starts as the first open source JMS specification implementation but ahs evolved to a event driven architecture backbone, with peristence, massive scalability and high availability. It has now in two flavors: classic and artemis.","title":"AMQ Studies"},{"location":"#characteristics","text":"Heterogeneous application integration Java, C/C++, .NET, Perl, PHP, Python, Ruby JMS compliant from design pub / sub and point-to-point communication style. With Topic, subscription may be durable which means they retain a copy of each message sent to the topic until the subscriber consumes them Guarantee the mesage will be delivered once and only once to each consumer of a queue or a durable topic. Support the sending and acknowledgement of multiple messages in a single local transaction Support XA transaction in Java using JTA Message can be persisted in permanent storage, and will survice server crashes and restart. Support HTTP/S via REST call, STOMP, MQTT, AMQT Provide clustering model where messages can be intelligently load balanced between the servers in the cluster, according to the number of consumers on each node, and whether they are ready for messages","title":"Characteristics"},{"location":"#when-to-use-it","text":"For point to point communication between Java microservices To replace RPC style synchronous calls Systems that rely upon synchronous requests typically have a limited ability to scale because eventually requests will begin to back up, thereby slowing the whole system. To adopt more loosely coupling between applications Loosely coupled architectures, on the other hand, exhibit fewer dependencies, making them better at handling unforeseen changes. Not only will a change to one component in the system not ripple across the entire system, but component interaction is also dramatically simplified. To implement stateful operation for complex event processing","title":"When to use it"},{"location":"#high-availability","text":"","title":"High Availability"},{"location":"#jms-summary","text":"The goal of JMS is to provide a vendor neutral API for messaging in Java. It is an abstraction layer between Java class and Message Oriented Middleware. JMS client: Java application to send and receive messages. JMS producer: A client application that creates and sends JMS messages. JMS consumer: A client application that receives and processes JMS messages. JMS provider: The implementation of the JMS interfaces to integrate with a specific MOM. JMS message: carry data and meta data between clients JMS domains: styles of messaging: point-to-point and publish/subscribe. Administered objects: Preconfigured JMS objects, accessible via JNDI, contain provider configuration to be used by clients. Connection factory: Clients use a connection factory to create connections to the JMS provider. Destination: An object to which messages are addressed and sent and from which messages are received. See producer and consumer code under the examples/basicjms folder and the explanation note .","title":"JMS Summary"},{"location":"basicjms/","text":"Basic JMS examples Some example of the JMS consumer and producer API and implementation considerations. Pre-requisites Be sure to have access to Active MQ artemis broker, in docker or on a cluster. The JMS APIs The basic api can be summarized in the following diagram from codenotfound.com ConnectionFactory is used to create JMS connection to the provider. It needs the broker URL, username and password. Connection is the encapsulation to the TCP/IP socket between the client and the provider. Always close connection to avoid congestion on the Provider side. A session is a single-threaded context for producing and consuming messages. A session provides a transactional context with which to group a set of sends and receives into an atomic unit of work. A MessageProducer is an object that is created by a session and used for sending messages to a destination A MessageConsumer is an object that is created by a session and used for receiving messages Destination is a queue or a topic Producing text message","title":"JMS Basis"},{"location":"basicjms/#basic-jms-examples","text":"Some example of the JMS consumer and producer API and implementation considerations.","title":"Basic JMS examples"},{"location":"basicjms/#pre-requisites","text":"Be sure to have access to Active MQ artemis broker, in docker or on a cluster.","title":"Pre-requisites"},{"location":"basicjms/#the-jms-apis","text":"The basic api can be summarized in the following diagram from codenotfound.com ConnectionFactory is used to create JMS connection to the provider. It needs the broker URL, username and password. Connection is the encapsulation to the TCP/IP socket between the client and the provider. Always close connection to avoid congestion on the Provider side. A session is a single-threaded context for producing and consuming messages. A session provides a transactional context with which to group a set of sends and receives into an atomic unit of work. A MessageProducer is an object that is created by a session and used for sending messages to a destination A MessageConsumer is an object that is created by a session and used for receiving messages Destination is a queue or a topic","title":"The JMS APIs"},{"location":"basicjms/#producing-text-message","text":"","title":"Producing text message"},{"location":"deployment/","text":"AMQ Deployments Run local using docker Classical Active MQ docker run -d \\ --name activemq -p 8161:8161 -p 61616:61616 -p 61613:61613 \\ -p 61617:61617 smaject/activemq Matching dockerfile is here where we can see the different exposed ports. Access the ActiveMQ admin-console as usual. Just invoke http://localhost:8161/admin/ admin/admin For the Artemis version docker run -it -p 61616:61616 -p 8161:8161 -v <broker folder on host>:/var/lib/artemis-instance artemis-centos docker run -d -e 'ARTEMIS_MIN_MEMORY=1512M' -e 'ARTEMIS_MAX_MEMORY=3048M' -e ARTEMIS_USERNAME=admin -e ARTEMIS_PASSWORD=password -p 61616:61616 -p 8161:8161 vromero/activemq-artemis The artemis management console: Running on Openshift","title":"Deployments"},{"location":"deployment/#amq-deployments","text":"","title":"AMQ Deployments"},{"location":"deployment/#run-local-using-docker","text":"Classical Active MQ docker run -d \\ --name activemq -p 8161:8161 -p 61616:61616 -p 61613:61613 \\ -p 61617:61617 smaject/activemq Matching dockerfile is here where we can see the different exposed ports. Access the ActiveMQ admin-console as usual. Just invoke http://localhost:8161/admin/ admin/admin For the Artemis version docker run -it -p 61616:61616 -p 8161:8161 -v <broker folder on host>:/var/lib/artemis-instance artemis-centos docker run -d -e 'ARTEMIS_MIN_MEMORY=1512M' -e 'ARTEMIS_MAX_MEMORY=3048M' -e ARTEMIS_USERNAME=admin -e ARTEMIS_PASSWORD=password -p 61616:61616 -p 8161:8161 vromero/activemq-artemis The artemis management console:","title":"Run local using docker"},{"location":"deployment/#running-on-openshift","text":"","title":"Running on Openshift"}]}